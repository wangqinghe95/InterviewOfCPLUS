## 进程、线程、协程的区别和联系？

---

## 堆和栈的区别？

    + 管理方式不同：栈是由编译自动管理，堆是由程序员申请释放，容易产生内存泄漏
    + 空间大小不同：一般在32位操作系统下，堆最大能到 4GB,栈是 MB 级别大小
    + 是否会产生碎片：堆频繁使用new/delete会造成内存空间的不连续，从而造成大量的碎片，是程序效率降低
    + 生长方向不同：栈是从高地址向低地址方向增长，堆是低地址向高地址方向增长
    + 分配方式不同：堆都是动态分配的，但是栈既有静态分配，还有动态分配。静态分配是编译器完成，动态分配是由malloc函数完成，并且也是由编译器完成内存释放。
    + 分配效率不同：栈是由机器系统提供的数据结构，计算机会在底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈的都有专门的指令执行；堆是由函数库提供，采用一定的算法去内存中寻找足够大小的空间。
    + 存储结构不同：栈存储的数据是先进后出，堆存储的数据方式是树
    
    [C++内存分配方式详解](https://blog.csdn.net/u013007900/article/details/79338653)

---

## 介绍几种典型的锁？
+ 读写锁
    - 多个读者可以同时进行读；
    - 写者必须互斥（只允许一个写者写，也不能读者写者同时进行）；
    - 写者优先于读者（一旦有写者，则后续读者必须等待，唤醒时优先考虑写者）
+ 互斥锁
    - 一次只能一个线程拥有互斥锁，其他线程只有等待；
    - 互斥锁在抢锁失败的情况下主动放弃 CPU 进入睡眠状态直至锁的状态改变时再唤醒，而操作系统负责线程调度，为了实现锁状态发生改变时唤醒阻塞的线程或者进程，需要把锁交给操作系统管理，所以互斥锁在加锁时涉及上下文的切换。互斥锁实际上的一种可能是先自旋一段时间，当自旋时间超过阈值之后再将线程投入睡眠中，因此在并发运算中使用互斥锁的效果并不亚于自旋锁；
    - 互斥锁的一个明显缺点是他只有两种状态，锁定和非锁定；
+ 条件变量
    - 条件变量允许线程阻塞和等待另一个线程发送信号的方法弥补互斥锁的不足，它常与互斥锁一起使用，以免出现竞态条件。
    - 当条件不满足时，线程往往解开相应的互斥锁并阻塞线程然后等待条件发生变化。一旦其他的线程改变了条件变量时，它将通知相应的条件变量唤醒一个或多个正被此条件变量阻塞的线程。总的来说，互斥锁是线程互斥的机制，而条件变量则是同步机制；
+ 自旋锁
    - 如果进程和线程无法取得锁，进线程不会立刻放弃 CPU 时间片，而是一致循环尝试获取锁，直至获取为止。如果别的线程长时间占有锁那么自旋锁就是在浪费 CPU 做无用功，而自旋锁一般应用于加锁时间很短的场景，此时的效率会比较高；

---

## 如何用代码判断大小端存储？

## 一个进程能创建多少线程，和什么有关？