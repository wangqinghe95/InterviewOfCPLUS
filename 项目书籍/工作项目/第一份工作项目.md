<!--
 * @Description: 
 * @Version: 2.0
 * @Autor: wanghao
 * @Date: 2021-09-26 15:33:11
 * @LastEditors: wanghao
 * @LastEditTime: 2021-09-27 13:02:38
-->

# 相机库项目
1. 介绍：相机库项目是将不同厂家设备、不同型号、不同版本的所有使用的相机使用接口整合到一个动态库中，维护一个统一的接口，相机设备大概有海康，大华，大力等。
2. 具体实现：根据读取的配置文件中的参数不同，去找对应库的对应接口。使用一个相机类父类，封装登陆，退出，拍照等公共接口函数，继承两个子类-可见光相机类，红外相机类。可见光相机有拍照，调焦等接口；红外有指定区域拍照，调倍，取区域温度等接口。
3. 使用者：本组的成员或者算法组的同事。算法组的同事是使用python调用，所以外侧还要封装一层 C 接口。

---

# RCF机器人后台程序重构
1. 介绍：使用RCF微服务技术，将程序的相机库部分服务提取出来，单独生成一个可执行程序，监听请求并根据传入的参数，处理对应功能请求；
2. 个人理解：就是相当于已经封装好了一个socket监听和http数据通信请求，客户端通过封装好的连接请求发送数据，服务节点时刻监听连接请求，有请求后根据传入的序列化的数据参数，做指定的动作，并且将执行后的数据返回给客户端。
3. 封装的内容是对应的相机的有关内容，按照RCF框架的格式将后端对应的函数接口移植到框架中。

---

# 防疫机器人
1. 介绍：使用机器人身上的红外和可见光拍照后，用算法组提供的接口获取到人脸位置区域信息，将获取的数据和照片等信息通过websocket传递到前端，在网页上实时显示人脸区域最高温度，同时将对应的数据存储到数据库中。
2. websocket：http格式，http通信建立后双方进行一次参数带有websocket字段的通信，确定websokcet通信协议。

# 涉及到知识点：
1. 线程的创建使用销毁过程，线程池的使用；
	+ 同一进程下的所有线程共享文件描述符表，信号的处理方式，当前工作目录树，用户ID和组ID，内存地址空间；每个线程都有自己的线程ID，处理器现场和栈指针，独立的栈空间，errno变量，信号屏蔽字，调度优先级。
	+ 线程相关函数：
		- pthread_self()：获取线程ID；
		- pthread_create()：线程创建；
		- pthread_exit()：线程退出
		- pthread_join()：等待线程结束
		- pthread_detach()：线程分离
		- pthread_cancel()：线程取消
	+ 线程和进程函数对比：(进程没有对应的线程分离的函数)
		- fork => pthread_create
		- exit => pthread_exit
		- waitpid => pthread_join
		- kill => pthread_cancel
		- getpid => pthread_self

---

2. 进程间通信机制和原理
	+ 进程间通信的目的
		1. 数据传输：一个进程需要将数据发送给另外一个进程；
		2. 共享数据：多个进程要操作共享数据；
		3. 信息传递：一个进程需要对另一个进程发送消息；
		4. 资源共享：多个进程共享同样的数据；
		5. 进程控制：有些进程希望控制另一个进程的执行；
	+ 进程间通信概念：每个进程都有自己的用户地址空间，每个进程的变量在另外一个进程中都是不可见的。所以进程间通信必须通过内核，在内核中开辟一块缓冲区后一个进程将自己的数据拷贝到内核中，另一个进程则从这个缓冲区中取走数据。内核提供的这种机制被称为进程间通信。
	+ 进程通信方式：
		1. 管道：有名管道、匿名管道
		2. 信号；
		3. 消息队列
		4. 共享内存
		5. 信号量
		6. 套接字
---

3. 线程间通信
	1. 互斥锁：
		+ 概念：访问共享资源前用互斥量对资源进行加锁，访问结束后释放。其他试图再次对资源上锁的线程都会被阻塞，直到当前线程释放该锁。当释放互斥量时有一个以上的线程阻塞，那么所有该锁上的阻塞线程都会变成可运行状态，第一个变为可运行状态的线程可以对资源加锁，其他线程则会变成重新阻塞状态继续等待资源变成可用状态。
		+ 常用函数：
			- pthread_mutex_init():互斥锁初始化
			- pthread_mutex_destory:销毁互斥
			- pthread_mutex_lock:加锁
			- pthread_mutex_unlock:解锁
		+ 互斥量的死锁避免：
			- 预防死锁：破坏死锁产生的四个条件：互斥条件，不剥夺条件，请求和保持条件以及循环等待条件；
			- 避免死锁：在每次资源分配前计算此次资源分配的安全性。银行家算法。
			- 检测死锁：检测到死锁后通过资源剥夺、撤销进程、进程回退等方法解除死锁。
	2. 读写锁：
		+ 概念：加载写状态的锁时，其他的线程的请求都会被阻塞；加载读状态锁时，写状态下的锁会被阻塞。
		+ 常用函数：
			1. pthread_rwlock_init()
			2. pthread_rwlock_destory()
			3. pthread_rwlock_rdlock();
			4. pthread_rwlock_wrlock();
			5. pthread_rwlock_unlock();
	3. 条件变量：
		+ 概念：一般同互斥锁同时使用，互斥锁用于上锁，条件变量用于等待，运行线程以无竞争的方式等待特定的条件产生。
		+ 常用函数：
			1. pthread_cond_init()
			2. pthread_cond_destory()
			3. pthread_cond_wait()	// 无条件等待条件变量变为真
			4. pthread_cond_timewait()	//
	4. 信号量：
		+ 信号量实际上是一个非负的整数计数器，用来实现对公共资源的控制，当公共资源增加时，信号量就增加；反之则减少。
		+ 常用函数：
			1. sem_init()
			2. sem_destory()
			3. sem_post()	// 信号量+1
			4. sem_wait()	// 信号量-1
			5. sem_getvalue()