# IOS七层模型是什么？各自的功能是什么？
1. 物理层：底层数据传输，如网线、网卡标准；单位比特流
2. 数据链路层：定义数据的基本格式，如网卡MAC地址，单位帧；
3. 网络层：定义IP编址，路由功能；如不同设备的数据转发；单位包；
4. 传输层：端到端传输数据的基本功能，如TCP、UDP；单位段；
5. 会话层：控制应用程序之间会话能力，如不同软件数据分发给不同软件；
6. 标识层：数据格式标识，基本压缩解密功能；
7. 应用层：各种应用软件，包括web应用；

**总结：**
+ 网络七层是一个标准，而非实现；
+ 网络四层模型是一个实现的应用模型；
+ 网络四层模型是由七层模型简化合并而来；

---

# TCP三次握手过程

# 什么是TCP粘包/拆包，发生的原因？
+ 一个完整的业务可能会被TCP拆分多个包进行发送，也可能把多个小包封装成一个大的数据包发送，这个就是TCP的拆包和粘包问题；
+ 原因：
    - 应用程序写入数据的字节大小大于套接字发送缓冲区的大小；
    - 进行 MSS 大小的 TCP 分段。（MSS = TCP 报文段长度-TCP首部长度）；
    - 以太网的 payload 大于 MTU 进行 IP 分片。（MTU：一种通信协议的某一层上面所能通过的最大数据包大小）；
+ 解决方案：
    1. 消息定长；
    2. 再包尾部增加回车或者空格符等特殊符号进行分割；
    3. 将消息分为消息头和消息尾；
    4. 使用其他复杂的协议，如 RTMP 协议等；

---

# 一个TCP连接可以对应几个HTTP请求？
+ 如果维持连接，一个 TCP 连接，可以发送多个 HTTP 请求的；

---

# 一个TCP连接中HTTP请求发送可以一起发送吗？
+ HTTP/1.1 存在一个问题，单个 TCP 连接再同一时刻只能处理一个请求，意思是说，两个请求的生命周期不能重叠，任意两个 HTTP 请求从开始到结束的时间在同一个 TCP 连接里不能重叠。
+ HTTP/1.1 中存在 Pipelinning 技术是可以完成多个请求同时发送，但浏览器是默认关闭的，所以默认一个 TCP 连接中多个请求一起发送的功能是不可用的。
+ HTTP2 中由于 multiplexing 特点存在，多个 HTTP 请求可以在同一个 TCP 连接中并行进行；
+ 在 HTTP/1.1 时代中，浏览器是如何提高记载效率的：
    - 维持和服务器已经建立的 TCP 连接，在同一连接中处理多个请求；
    - 和服务器建立多个 TCP 连接；

---

# 一个完整的HTTP请求包括哪些内容？
+ 域名解析；
+ 发起 TCP 的三次握手；
+ 建立 TCP 三次握手后发起 HTTP 请求；
+ 服务器响应 http 请求，浏览器得到 html 代码；
+ 浏览器解析 html 代码，并请求代码中的资源（js、css、图片等）
+ 浏览器对页面进行渲染呈现给客户；

---

# HTTP长连接和短连接的区别
+ 短连接：客户端和服务器每进行一次 HTTP 操作，就建立一次连接，任务结束就中断连接,http/1.0 默认使用；
+ 长连接：保持连接性，http/1.1 默认使用；

---

# HTTP请求方法？
+ 客户端发送的请求报文第一行为请求行，包含了方法字段；
+ 根据 HTTP 标准，HTTP 请求可以使用多种请求方法：
    - HTTP/1.0 定义了三种请求方法：GET、POST、HEAD方法；
    - HTTP/1.1 新增了六种请求方法：OPTIONS、PUT、PATCH、DELETE、TRACE、CONNECT 方法；
+ 方法具体介绍：
    - GET：请求指定的页面信息，并返回实体主体；
    - HEAD：类似于 GET 请求，只不过返回响应中没有具体内容，用于获取报头；
    - POST：向指定资源提交数据进行处理请求。数据倍包含在请求体中，POST 请求可能会导致新的资源的建立或已有的资源的修改；
    - PUT：从客户端向服务器传送的数据取代指定的文档的内容；
    - DELETE：请求服务器删除指定的页面；
    - CONNECT：HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器；
    - OPTIONS：允许客户端查看服务器的性能；
    - TRACE：回显服务器的请求，主要是用于测试或诊断；
    - PATCH：对 PUT 方法的补充，用来对已知资源进行局部更新；

---

# HTTP请求和响应报文主要有哪些字段？
+ 请求报文：
    - 请求行：Request Line；
    - 请求头：Request Headers；
    - 请求体：Request Body；
+ 响应报文：
    - 状态行：Status Line；
    - 响应头：Response Headers;
    - 响应体：Reponse Body；

---

# HTTP和HTTPS协议的区别？
+ HTTP 协议传输的数据都是未加密的，也就是明文，因此使用 HTTP 协议传输协议隐私信息非常不安全，HTTPS 协议是由 SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比 HTTP 协议安全；
+ HTTPS 协议需要用到 ca 申请证书，一般免费证书较少，因而需要收费；
+ HTTP 和 HTTPS 使用的是不同的连接方式，用的端口也是不一样的，前者是 443，后者是 80；

---

# GET和POST的区别？
+ get 是获取数据，post 是获取数据；
+ get 是把请求的数据放到 url 上，以 ？ 分割 URL 和传输数据，参数是以 & 相连，所以 get 是不太安全，而 post 是把数据放到 HTTP 的包内部（request body）
+ get 提交的数据最大是 2k（取决于浏览器），post 理论上没有限制；
+ get  产生一个 TCP 包，浏览器会把 http header 和 data 一并发送出去，服务器响应 200（返回数据）， POST 产生两个 TCP 数据包，浏览先发送 header，服务器响应 100 continue，浏览器再发送  data，服务器响应 200 ok（返回数据）；
+ get 请求会被浏览器缓存，而 post 不会，除非手动设置；
+ 本质区别：get 是幂等的，而 POST 不是幂等的；
**补充：** 这里的幂等性指的是一个和多次请求某一个资源应该具有同样的副作用，简单了来说意味着对同一 URL 的多个请求应该同样的结果；

**总结：** 正因为它们有这样的区别，所以不该且不能用 get 请求做数据的增删改这样有副作用的操作，因为 get 的请求是幂等的，在网络不好的隧道中会重新尝试，如果用 get 请求增数据，会有重复操作的风险，而这样的重复操作可能会导致副作用。

---

# HTTPS是如何保证数据传输安全的，整体流程是什么？（SSL是怎么保证安全的）
+ 客户端向服务器发送 SSL 请求；
+ 服务器把公钥发送给客户端，并且服务端保存着唯一的私钥；
+ 客户端用公钥对双方通信的对称密钥进行加密，并发送给服务器端；
+ 服务器利用自己唯一的私钥对客户端发送来的对称密钥进行解密；
+ 进行数据传输，客户端和服务器双方使用公有的相同的对称密钥对数据进行加密解密，可以保证数据在传输过程中的安全，即使第三方获得数据包，也无法对其进行加密，解密和篡改；
+ SSL/TLS 协议的基本思路是采用公钥加密法，也就是客户端向服务器索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密；

---

# 如何保证公钥不被篡改？
+ 把公钥放到数字证书中，只要证书是可信的，公钥就是可信的；
+ 公钥加密计算太大，如何减少耗用的时间：
    - 每一次对话，客户端和服务端都生成一个“对话密钥”，用它来加密信息，由于“对话密钥”是对称加密，所以运算速度非常快，而服务器公钥只用于加密“对话密钥”本身，这样就减少了加密运算的消耗时间。
    1. 客户端向服务端索要并验证公钥；
    2. 双方协商生成“对话密钥”；
    3. 双方采用“对话密钥”进行加密通信。

---

# 在浏览器中输入url地址后显示主页的过程？
+ 根据域名，进行 DNS 解析；
+ 拿到解析的 IP 地址，建立 TCP 连接；
+ 向 IP 地址发送 HTTP 请求；
+ 服务器处理请求，并返回响应结果；
+ 关闭 TCP 连接；
+ 浏览器解析 HTML，布局渲染；

---

# 浏览器地址栏输入一个url，回车后背后进行哪些技术步骤？
+ 解析url获取IP地址
    1. 查看浏览器缓存；若没有
    2. 查看本机 host 文件，调用 API，linux 下 调用 socket 函数 gethostbyname 查看本地的 host 文件；如还是没有：
    3. 向 DNS 服务器发送 DNS 请求，查询本地 DNS 服务器，递归查询到对应的 IP 地址，使用的是 UDP 协议；
    4. 有了服务器的 IP 地址和默认的端口号后（http 默认是 80，https 默认是 443）后，调用 socket 建立 TCP 连接；
    5. 三次握手成功建立连接成功后，如果是 http 就可以开始传输数据了；
    6. 如果不是 http 协议，服务器会返回一个头 5 开头的重定向消息，把端口号换成 443，然后四次挥手断开连接；
    7. 三次握手建立连接后，再进行一次 SSL 加密技术来保证传输数据的安全性，保证数据在传输的过程中不被修改或者替换；
    8. 沟通好双方使用的认证算法，加密算法和检验算法，在此过程中还要检验对方的 CA 安全证书；
    9. 确认无误后开始通信，然后服务器会返回浏览器想要访问的网址的一些数据，在此过程中会将页面渲染，最终显示出我们看到的网页效果；

---

# cookie是什么？
+ HTTP 是无状态的，为了让 HTTP 协议尽可能的简单，使它可以处理大量事务，HTTP/1.1 引入 Cookie 来保存状态信息；
+ Cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器之后向同一服务器再次发送请求时被携带上，用于告知服务器两个请求是否来自同一浏览器。由于之后每次请求都会需要携带 Cookie 数据，因此会带来额外开销；
+ Cookie 曾一度用于客户端数据的存储，因为当时没有其他合适的存储方法而作为唯一的存储手段，新的浏览器 API 已经允许开发者直接将数据存储到本地，如使用 Web storage API（本地存储和会话存储）或者 IndexedDB；
+ cookie 是一种标识，用于标识浏览器的唯一性； session 可以理解为为一种数据结构，多数情况是一个键值对，存储在服务器上；

---

# cookie有什么用？
+ 会话状态管理（如用户登陆状态等需要记录的消息）
+ 个性化设置（如用户自定义设置、主题等）
+ 浏览器行为跟踪（如跟踪分析用户行为等）

---

# session知识总结？
+ 除了可以将用户信息通过cookie存储在用户浏览器中，也可以利用 Session 存储在服务端，存储在服务端的信息更安全；
+ Session 可以存储在服务器上的文件、数据库或者内存中，也可以将 Session 存储在 redis 这种内存型数据库中，效率会更高；
+ 使用 Session 维护用户登陆状态的过程如下：
    1. 用户进行登陆时，用户提交包含用户名和密码的表单，放入到 HTTP 请求报文中；
    2. 服务器验证该用户名和密码，如果正确则把用户信息存储到 redis 中，redis 中的 key 称为 Session ID；
    3. 服务器返回的响应的报文的 Set-Cookie 首部字段包含了这个 Session ID，客户端收到响应报文之后将该 Cookie 值存入到浏览器中；
    4. 客户端之后会对同一服务器进行请求时会包含该 Cookie 值，服务器收到之后提取出 Session ID，从 redis 中取出用户信息，继续之前的业务操作；

**注意：** Session ID 的安全性问题，不能让它倍恶意攻击者轻易的获取，那么就不能产生一个容易被猜到的 Session ID 值，此外，还需要经常重新生成 Session ID。对安全性要求极高的场景下，例如转账扽操作，除了使用 session 管理用户状态之外，还需要对用户进行重新验证，比如重新输入密码，或者使用短信验证等方式；

---

# session工作原理？
+ 客户端登陆完成之后，服务器会创建对应的 session，session 创建完之后，会把 session 的 id 发送给客户端，客户端再存储到浏览器中；
+ 这样客户端每次访问服务器时，都会带着 session id ，服务器拿着 session id 之后再内存中找到相应的 session 就可以正常的工作了；

---

# cookie 和 session 的区别？
+ Cookie 是客户端保持状态的方法；
    - Cookie 简单的理解就是存储由服务器发送至客户端保存的一段字符串，为了保持会话，服务器可以在响应客户端请求时将 Cookie 字符串放到 Set-Cookie 下，客户机收到 Cookie 之后之后保存这段字符串，之后再请求时候带上这个 Cookie 就可以被识别。
    - Cookie 在客户端上保存的形式只有两种，一种是会话 Cookie，一种是持久 Cookie，会话 Cookie 就是将服务器返回的 Cookie 字符串保存在内存中，关闭浏览器之后自动注销；持久 Cookie 则是存储在客户端磁盘上，其有效时间在服务器响应头中被指定，在有效期内，客户端再次请求服务器时都可以直接从本地取出。需要说明的是存放在磁盘上的 Cookie 是可以被多个浏览器代理所共享；
+ Session 是服务器保持状态的方法：
    - session 是保存在服务器上，也可以保存在数据库、文件或内存中，每个用户由独立的 session 记录用户在客户端的操作
    - 每个用户有一个独一无二的 session ID 作为 Session 文集的 hash 值，通过这个值可以锁定 session 结构的数据，这个 session 结构中存储了用户操作行为；
+ 当服务端需要识别客户端时就需要结合 Cookie。每次 HTTP 请求时，客户端都会发送响应的 Cookie 信息到服务端。实际上大多数应用都是用 Cookie 来实现 Session 跟踪的。第一次创建 Session 的时候，服务端会在 HTTP 协议中告诉客户端，需要在 Cookie 里面记录一个 Session ID，以后每次请求都会把这个会话 ID 发送到服务器，用于识别该 ID。

---

# SQL注入攻击？
+ 攻击者在 HTTP 请求中注入恶意的 SQL 代码，服务器使用参数构建数据库 SQL 命令时，恶意 SQL 会一起被构造，并在数据库中执行；
+ 防范 SQL 注入攻击：
    - web 端：1）有效性检验；2）限制字符串输入长度；
    - 服务端：1）不用拼接 SQL 字符串；2）使用预编译的 prepareStatement；3）有效性检验；4）过滤SQL需要的参数中的特殊字符，比如单引号，双引号；

---

# DNS是什么？
+ 域名系统：因特网上作为域名和IP地址互相映射的一个分布式数据库；
+ 通过主机名最终得到该主机名对应的 IP 地址过程叫做域名解析；

---

# DNS工作原理？
+ 将主机域名转换成 IP 地址，属于应用层协议，使用 UDP 传输；
+ 过程：浏览器缓存，再查操作系统缓存，路由器缓存，IPS 服务器缓存，根域名服务器缓存，顶级域名服务器缓存，主域名服务器缓存;
    - 主机向本地域名服务器的查询一般采用递归查询；
    - 本地服务器向根域名服务器查询是迭代查询；
+ 步骤：
    1. 当用户输入域名时，浏览器先检查自己缓存是否有这个域名映射的 ip 地址，有解析结束；
    2. 然后检查操作系统缓冲中有没有解析过的结果；
    3. 然后再请求本地域名服务器解析（LDNS）；
    4. 若没有命中直接跳到根域名服务器请求解析，根域名服务会返回一个主域名服务器地址；
    5. 此时 LDNS 再发送请求给上一步返回 gTLD（通用顶级域），接收请求的 gTLD 查找并返回对应的 Name Server 地址；
    6. Name Server 根据映射关系表找到 IP 地址，返回给 LDNS；
    7. LDNS 缓存这个域名和对应的 IP，把解析的结果返回给用户，用户根据 TTL 值缓存到本地缓存中，域名解析过程至此结束；

---

# 域名解析为什么要使用UDP协议？
+ 客户端向 DNS 服务器查询域名一般返回不超过 512 个字节，使用 UDP 传输就足够了；
+ UDP 比 TCP 速度快，一个请求一个应答即可；

---

# DNS解析过程？
+ 现在浏览器缓存中找该域名对应的 IP 地址；

# DNS负载均衡？

# RARP是什么？工作原理？

# 端口有效范围？