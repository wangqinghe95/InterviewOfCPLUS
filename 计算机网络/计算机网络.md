# IOS七层模型是什么？各自的功能是什么？
1. 物理层：底层数据传输，如网线、网卡标准；单位比特流
2. 数据链路层：定义数据的基本格式，如网卡MAC地址，单位帧；
3. 网络层：定义IP编址，路由功能；如不同设备的数据转发；单位包；
4. 传输层：端到端传输数据的基本功能，如TCP、UDP；单位段；
5. 会话层：控制应用程序之间会话能力，如不同软件数据分发给不同软件；
6. 标识层：数据格式标识，基本压缩解密功能；
7. 应用层：各种应用软件，包括web应用；

**总结：**
+ 网络七层是一个标准，而非实现；
+ 网络四层模型是一个实现的应用模型；
+ 网络四层模型是由七层模型简化合并而来；

---

# TCP三次握手过程

# 什么是TCP粘包/拆包，发生的原因？
+ 一个完整的业务可能会被TCP拆分多个包进行发送，也可能把多个小包封装成一个大的数据包发送，这个就是TCP的拆包和粘包问题；
+ 原因：
    - 应用程序写入数据的字节大小大于套接字发送缓冲区的大小；
    - 进行 MSS 大小的 TCP 分段。（MSS = TCP 报文段长度-TCP首部长度）；
    - 以太网的 payload 大于 MTU 进行 IP 分片。（MTU：一种通信协议的某一层上面所能通过的最大数据包大小）；
+ 解决方案：
    1. 消息定长；
    2. 再包尾部增加回车或者空格符等特殊符号进行分割；
    3. 将消息分为消息头和消息尾；
    4. 使用其他复杂的协议，如 RTMP 协议等；

---

# 一个TCP连接可以对应几个HTTP请求？
+ 如果维持连接，一个 TCP 连接，可以发送多个 HTTP 请求的；

---

# 一个TCP连接中HTTP请求发送可以一起发送吗？
+ HTTP/1.1 存在一个问题，单个 TCP 连接再同一时刻只能处理一个请求，意思是说，两个请求的生命周期不能重叠，任意两个 HTTP 请求从开始到结束的时间在同一个 TCP 连接里不能重叠。
+ HTTP/1.1 中存在 Pipelinning 技术是可以完成多个请求同时发送，但浏览器是默认关闭的，所以默认一个 TCP 连接中多个请求一起发送的功能是不可用的。
+ HTTP2 中由于 multiplexing 特点存在，多个 HTTP 请求可以在同一个 TCP 连接中并行进行；
+ 在 HTTP/1.1 时代中，浏览器是如何提高记载效率的：
    - 维持和服务器已经建立的 TCP 连接，在同一连接中处理多个请求；
    - 和服务器建立多个 TCP 连接；

---

# 一个完整的HTTP请求包括哪些内容？
+ 域名解析；
+ 发起 TCP 的三次握手；
+ 建立 TCP 三次握手后发起 HTTP 请求；
+ 服务器响应 http 请求，浏览器得到 html 代码；
+ 浏览器解析 html 代码，并请求代码中的资源（js、css、图片等）
+ 浏览器对页面进行渲染呈现给客户；

---

# HTTP长连接和短连接的区别
+ 短连接：客户端和服务器每进行一次 HTTP 操作，就建立一次连接，任务结束就中断连接,http/1.0 默认使用；
+ 长连接：保持连接性，http/1.1 默认使用；

---

# HTTP请求方法？
+ 客户端发送的请求报文第一行为请求行，包含了方法字段；
+ 根据 HTTP 标准，HTTP 请求可以使用多种请求方法：
    - HTTP/1.0 定义了三种请求方法：GET、POST、HEAD方法；
    - HTTP/1.1 新增了六种请求方法：OPTIONS、PUT、PATCH、DELETE、TRACE、CONNECT 方法；
+ 方法具体介绍：
    - GET：请求指定的页面信息，并返回实体主体；
    - HEAD：类似于 GET 请求，只不过返回响应中没有具体内容，用于获取报头；
    - POST：向指定资源提交数据进行处理请求。数据倍包含在请求体中，POST 请求可能会导致新的资源的建立或已有的资源的修改；
    - PUT：从客户端向服务器传送的数据取代指定的文档的内容；
    - DELETE：请求服务器删除指定的页面；
    - CONNECT：HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器；
    - OPTIONS：允许客户端查看服务器的性能；
    - TRACE：回显服务器的请求，主要是用于测试或诊断；
    - PATCH：对 PUT 方法的补充，用来对已知资源进行局部更新；

---

# HTTP请求和响应报文主要有哪些字段？
+ 请求报文：
    - 请求行：Request Line；
    - 请求头：Request Headers；
    - 请求体：Request Body；
+ 响应报文：
    - 状态行：Status Line；
    - 响应头：Response Headers;
    - 响应体：Reponse Body；

---

# HTTP和HTTPS协议的区别？
+ HTTP 协议传输的数据都是未加密的，也就是明文，因此使用 HTTP 协议传输协议隐私信息非常不安全，HTTPS 协议是由 SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比 HTTP 协议安全；
+ HTTPS 协议需要用到 ca 申请证书，一般免费证书较少，因而需要收费；
+ HTTP 和 HTTPS 使用的是不同的连接方式，用的端口也是不一样的，前者是 443，后者是 80；

---

# GET和POST的区别？
+ get 是获取数据，post 是获取数据；
+ get 是把请求的数据放到 url 上，以 ？ 分割 URL 和传输数据，参数是以 & 相连，所以 get 是不太安全，而 post 是把数据放到 HTTP 的包内部（request body）
+ get 提交的数据最大是 2k（取决于浏览器），post 理论上没有限制；
+ get  产生一个 TCP 包，浏览器会把 http header 和 data 一并发送出去，服务器响应 200（返回数据）， POST 产生两个 TCP 数据包，浏览先发送 header，服务器响应 100 continue，浏览器再发送  data，服务器响应 200 ok（返回数据）；
+ get 请求会被浏览器缓存，而 post 不会，除非手动设置；
+ 本质区别：get 是幂等的，而 POST 不是幂等的；
**补充：** 这里的幂等性指的是一个和多次请求某一个资源应该具有同样的副作用，简单了来说意味着对同一 URL 的多个请求应该同样的结果；

**总结：** 正因为它们有这样的区别，所以不该且不能用 get 请求做数据的增删改这样有副作用的操作，因为 get 的请求是幂等的，在网络不好的隧道中会重新尝试，如果用 get 请求增数据，会有重复操作的风险，而这样的重复操作可能会导致副作用。

---

# HTTPS是如何保证数据传输安全的，整体流程是什么？（SSL是怎么保证安全的）
+ 客户端向服务器发送 SSL 请求；
+ 服务器把公钥发送给客户端，并且服务端保存着唯一的私钥；
+ 客户端用公钥对双方通信的对称密钥进行加密，并发送给服务器端；
+ 服务器利用自己唯一的私钥对客户端发送来的对称密钥进行解密；
+ 进行数据传输，客户端和服务器双方使用公有的相同的对称密钥对数据进行加密解密，可以保证数据在传输过程中的安全，即使第三方获得数据包，也无法对其进行加密，解密和篡改；
+ SSL/TLS 协议的基本思路是采用公钥加密法，也就是客户端向服务器索要公钥，然后用公钥加密信息，服务器收到密文后，用自己的私钥解密；

---

# 如何保证公钥不被篡改？
+ 把公钥放到数字证书中，只要证书是可信的，公钥就是可信的；
+ 公钥加密计算太大，如何减少耗用的时间：
    - 每一次对话，客户端和服务端都生成一个“对话密钥”，用它来加密信息，由于“对话密钥”是对称加密，所以运算速度非常快，而服务器公钥只用于加密“对话密钥”本身，这样就减少了加密运算的消耗时间。
    1. 客户端向服务端索要并验证公钥；
    2. 双方协商生成“对话密钥”；
    3. 双方采用“对话密钥”进行加密通信。

---

# 在浏览器中输入url地址后显示主页的过程？

# 浏览器地址栏输入一个url，回车后背后进行哪些技术步骤？

# cookie是什么？

# cookie有什么用？

# session知识总结？

# session工作原理？

# cookie 和 session 的区别？

# SQL注入攻击？

# DNS是什么？
+ 域名系统：因特网上作为域名和IP地址互相映射的一个分布式数据库；
+ 通过主机名最终得到该主机名对应的 IP 地址过程叫做域名解析；

---

# DNS工作原理？

# 域名解析为什么要使用UDP协议？

# DNS解析过程？

# DNS负载均衡？

# RARP是什么？工作原理？

# 端口有效范围？