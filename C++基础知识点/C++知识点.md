# C和C++的区别
    [C和C++的区别](https://www.cnblogs.com/wanghao-boke/p/14613495.html)
    
    + 基础语法没用太大的区别？
    + C++ 多出一下语法和关键字，引用、new/delete、auto、explicit等
    + C++ 多了重载和虚函数
    + C++ 面向对象的部分，类、继承、对象
    + C++ 和 C 的设计思想和应用场景。处于对内存和执行效率的考虑，C优点是精简和高效，多用于操作系统和内核驱动；C++ 设计之初的目的就是把 C 繁杂的实现过程抽象成类，并且进行实例化管理，更适用做大型软件。C 更注重逻辑实现，C++ 更适合程序的整体设计。

# 基础语法

## main执行前和执行后的代码可能是什么?
    ### main 函数执行之前，注意是为了初始化系统相关资源：
        + 设置栈指针；
        + 初始化静态 static 变量和 global 全局变量，即 .data 段的内容；
        + 将未初始化部分的全局变量赋初始值，即 .bss 内容（数值型 short、int、long 为 0，bool 型为 false、指针为 null 等等）
        + 全局对象初始化，在 main 之前调用构造函数，这是可能执行前的一些代码；
        + 将 main 函数参数 argc、argv 等传递给 main 函数，然后才真正运行 main 函数；
        + attribute(constructor) //构造函数
    
    ### main 函数执行之后：
        + 全局的析构函数会在 main 执行；
        + 可以注册一个 atexit 函数，它会在 main 之后执行；
        + attribute((destructor))
        
---

## 形参和实参的区别？
    + 新参变量只有在被调用的时候才会分配内存单元，在调用结束时即可释放内存单元，因此，形参只有在函数内部有效，函数调用结束返回主调函数后则不能使用该形参变量
    + 实参可以是常量、变量、表达式、函数等，无论实参是何种类型的量，在进行函数调用时，他们都必须是确定的值，以便把这些值传递给形参，因此应预先用赋值、输入等方法使实参获得确定的值
    + 实参和形参在数量上，类型上、顺序上应该保持严格一致，否则会发生“类型不匹配错误”
    + 函数调用中发生的数据传送是单向的，即只能把实参的值传递给形参，而不能把形参的值反向的传递给实参，因此在函数调用过程中，形参的值发生变化不会影响到实参
    + 当形参和实参不是指针类型时，在函数运行时，形和参实参是不同的变量，他们在内存中位于不同的位置，形参将实参传递过来的内容复制一份，而在该函数运行结束时形参被释放，而实参内容不会改变
    
---

## 结构体内存对齐问题？
   + 结构体成员每个成员的相对结构体首地址的偏移量是对齐参数的整数倍，首位元素是对齐参数的 0 倍；
   + 结构体变量所占空间大小是对齐参数的整数，如有需要在最后一个成员末尾填充字节达到该要求；
   
---

## 内存对齐的理解以及理解？
    + 分配内存的顺序是按照变量声明的顺序
    + 每个变量相对于起始位置的偏移量必须是该变量类型的整数倍，不是整数倍的空出内存，直到偏移量为整数倍为止
    + 最后整个结构体的大小必须是里面变量类型最大值的整数倍
    
---

## 如何获取结构体成员相对于结构体开头的字节偏移量？
    (unsigned long)(&(type.Member)) - (unsigned long)(&(type))
    
---

## 判断结构体比较是否相等？
    + 重载 “==” 操作符
    + 对结构体变量一个个比较
    + 指针直接比较，如果保存的是同一个实例，则两个指针保存的地址是一样的
    
---

## 指针和引用的区别？
    + 指针是一个实体，需要分配内存；引用只是变量的别名，不需要分配内存空间；
    + 引用在定义时候必须进行初始化，并且不能改变；指针在定义的时候不一定要进行初始化，并且指向的空间可变；
    + 有多级指针，但是没有多级引用。只能有以及引用；
    + 指针和引用的自增运算结果不一样；（指针是指向下一个空间，引用是引用的变量值加 1 ）；
    + sizeof 引用得到的结果是引用所指向的变量（对象）的大小；sizeof 指针得到的指针本身的大小；
    + 使用指针前最后做类型检查，防止野指针的出现；
    + 引用底层是用指针实现的；
    + 作为参数时，传指针实际上是传值，传递的值是指针的地址；传引用的实质是传地址，传递的是变量的地址；
    
---

## 在汇编层面上解释一下引用？
    + 引用在底层是用指针，更准确的是用地址实现的
    + 但从高级语言一级来说，指针和引用没有关系，引用就是另一个变量的别名
    + 引用占据一个内存空间，存储一个地址，一般是4个字节
    
---

## const 的用法？（常量指针和指针常量的区别，C++ 中顶层 const 和底层 const）
    const 修饰变量、数组、指针、函数参数、函数返回值、引用都是对修饰对象的声明为只读属性，不允许修改 const 所修饰的对象
    const 修饰类成员函数、类限制成员函数和类对类成员变量的修改
   
   常量指针：是 const 修饰的常量的指针，int const *p/const int* p，*p的值不可变
   指针常量：是 const 修饰的不能改变指向的指针，int* const p，p值不可变
   
---

## static 的作用？（静态变量什么时候初始化）
    ### 不考虑类时：
        1. 修饰全局变量作用是隐藏：修饰全局变量和函数时隐藏它们的全局可见性，限制它们只能在该文件所在的编译模块中使用；
        2. 修饰局部变量的作用是改变局部变量的生存周期：静态变量在函数内定义，始终存在，只进行一次初始化。作用区域与局部变量相同，生存周期等同于程序的生存周期；
        3. 默认初始值：static 修饰的变量没有初始化的话存储在全局未初始化区域，存储在该区域的变量统一默认为 0；

    ### 考虑类时：
        4. 修饰类成员变量：该变量只与类关联，不与类的对象关联。定义是要分配空间，不能在类声明中初始化，必须在类定义外部初始化，初始化时不必标识为 static ；可以被非 static 成员函数任意访问；
        5. 修饰成员函数：该函数没有 this 指针，无法访问类的非 static 成员函数和非 static 成员变量；不能被声明为 const、虚函数、volatile；可以被非 static 成员函数任意访问；

---

## strlen 和 sizeof 的区别？
    1. sizeof 是运算符，在编译时就获得了结果；strlen 是字符处理的库函数；
    2. sizeof 的参数可以是任何数据的类型或任何数据（sizeof参数不退化）；strlen 的参数只能是字符指针且结尾是 '\0' 的字符串；
    3. 因为 sizeof 值在编译时就已经得到了，所以它不能用来得到动态分配存储空间的大小；

---

## extern"C" 的用法？
    + 功能：extern "C" 的作用是为了实现 C/C++ 混编；
    + 原因：C++ 为了支持重载功能，编译器在编译阶段会对函数名进行“再次重命名”-由原有的函数名和各个参数的数据类型构成一个新的函数名；但是 C 的编译器不支持重载，也就没有了这步额外的步骤；这个结果也就意味着在 C 和 C++ 进行混合编译时，会造成编译器在程序链接阶段无法找到函数具体的实现，导致链接失败。
    + 解决方法：而 extern "C" 就是为了解决这个问题的，extern "C" 修饰的变量和函数都是按照 C 语言方式进行编译和链接的；

---

## 宏定义（define）和 typedef 的区别？
    + 宏主要是用于定义常量及书写复杂的内容；typedef 主要是定义类型别名；
    + 宏替换发生在预处理阶段，属于文本插入替换；typedef 是编译的一部分；
    + 宏不检查类型； typedef 会检查数据类型；
    + 宏不是语句，不在结尾处加分号； typedef 是语句，要加分号标识结束；
    + 注意对指针的操作；typedef char *p_char 和 define p_char char* 差别巨大

---

## 宏定义（define）和函数的区别？
    + 宏定义在预编译期间完成替换，之后被替换的文本参与编译，相当于直接插入了代码，不存在调用步骤，执行速度更快；函数调用在运行时需要跳转到具体调用函数；
    + 宏定义属于在结构中插入代码，没有返回值；函数调用具有返回值；
    + 宏定义参数没有类型，不进行类型检查；函数参数具有类型，需要检查类型；
    + 宏定义在最后不需要加分号；

---

## 宏定义（define）和 const 的区别？
    ## 编译阶段
        + define 在编译的预处理阶段起作用，而const 在编译、运行时起作用
    ## 安全性
        + define 只做替换，不做类型检查和计算，也不求解，容易产生错误，一般最好加上一个大括号包含住所有内容，不然很容易出现错误；
        + const 常量有数据类型，编译器可以对其进行类型安全检查
    ## 内存占用
        + define 只是将宏名称进行替换，在内存中会产生多份相同的备份；const 在程序运行时只有一份备份，且可以执行常量折叠，能将复杂的表达式计算出结果放到常量表中；
        + 宏定义的数据没有分配内存，只是插入替换；const 定义的变量只是值不能改变，但要分配内存空间；

---

## 宏定义（define）和内联函数的区别？
    + define 是关键字，inline 是函数
    + 宏定义在预处理阶段进行文本替换，inline 函数在编译阶段进行替换
    + inline 函数有类型检查，相比于宏定义更安全

---

## 变量声明和定义的区别？（声明和定义的区别？）
    + 声明仅仅是把变量声明的位置提供给编译器，并不分配内存空间；定义是要在定义的地方为其分配存储空间；
    + 相同变量可以在多处声明（外部extern），但只能在一处定义；

---

## 不同的指针类型？（数组名和指针， a 和 &a 之间的区别）
    ### 数组名和指针
        + 二者都可以通过增减偏移量来访问数组中的元素；
        + 数组名不是真正意义上的指针，可以理解为常指针，所以数组名没有自增自减的操作；
        + 当数组名当作形参传递给调用函数后，就退化成了一般指针了，也就有了自增自减的操作了。但sizeof运算符不能再得到原数组的大小了；

---

## 野指针和悬空指针？
    + 都是指向无效（无效是指“不安全不可控”的）内存区域的指针，访问行为将会导致为定义行为;
    + 野指针指的是没有初始化的指针；悬空指针是指向的区域已经被释放了的指针;
    + 解决方案：
        - 野指针：定义指针变量要及时初始化，要么置空；
        - 悬空指针：指针释放操作后要及时置空；

---

## 初始化和赋值的区别？
    + 初始化的发生过程在编译阶段，赋值发生在函数或者程序运行时；
    + 对于基本数据类型来说，两者的差别不大，但是对于用户自定义数据类型区别很大：
        - 对于初始化操作，程序调用了类的构造函数；
        - 对于赋值操作，程序需要重载 = 号，调用拷贝构造函数

---

## 什么是内存池，如何实现？（待完善）
    + 一次性向操作系统申请一大堆内存，在此之上构建需要的对象，用完之后统一返还给操作系统。这样做最大的好处是避免了频繁的 new/delete 开销和带来的内存碎片问题。

---

## 什么是内存泄漏？如何检查和避免？（内存泄露后果，如何检测，解决方案？）
    + 内存泄漏一般指堆内存泄漏。应用程序使用 new/malloc/realloc 等函数从堆中申请内存，在使用结束后没有显示的释放掉该内存块，导致该内存在运行成员未结束时无法继续使用，这个现象被称为内存泄漏；
    + 避免内存泄漏的几种方法：
        1. 计数法：使用一个变量来记录内存申请和释放的次数，在使用内存分配函数时加一，在释放内存时减一，在程序执行完检测该变量的值，如果不为0则表示内存泄漏；
        2. 一定要把基类的虚构函数声明为虚函数；
        3. 对象数组的释放要用到 delete[]；
        4. 有 new 就要有 delete， 有 malloc 就要有 free

+ C++ 函数调用压栈过程？

+ C++ 将临时变量作为返回值时的处理过程？

+ 全局变量和局部变量有什么区别？（全局变量和 static 变量区别？）

## 方法调用的原理？
    

## 函数指针是什么？
    + 概念：函数指针指向的是特殊的数据类型，函数的类型是由其返回的数据类型和其参数列表共同决定的，而函数名称不是其类型的一部分；
    + 函数指针的声明方法： 
        - int (*pf)(const int&, const int&); 其中
        
+ 函数调用过程中栈的变化，返回值和参数变量哪个先入栈？

+ printf 函数实现原理？

+ lambda函数的全部知识？

+ 将字符串 “hello world” 从开始到打印屏幕上的全过程？

+ cout 和 printf 有什么区别？

+ ifdef、endif 代表着什么？

+ 在使用额外空间的情况下，交换两个人数，你有几种方法？

+ strcpy 和 memcpy 的区别？

+ 程序在执行 int main(int argc, char *argv[]) 时的内存结构？

+ const char* 和 string 之间是什么关系？

+ 如何快速定位错误出现的地方？

+ strcpy、sprintf、memcpy 这三个函数的不同之处？

+ Debug 和 release 的区别？

+ main 函数的返回值有什么考究之处的？

+ strcpy 函数和 strncpy 函数的区别？哪个更安全？

+ 回调函数的作用？

+ 一致性哈希？

+ C++ 从代码到可执行函数经历了什么？（预编译、编译、汇编、链接（静态链接、动态链接））

------

**关键字**

+ malloc 和 free 实现的原理？

+ malloc、realloc、calloc 区别？

+ new/delete 和 malloc/free 的区别？（new 和 malloc 的区别？）

+ new 和 delete 是如何实现的？（delete 是如何知道要释放内存的大小？）

+ malloc 申请的空间能用 delete 释放吗？

+ delete 和 delete [] 的区别？（delete、delete []、alloctor 有什么作用？）

+ C++ 有几种类型的 new？

+ c++ 中 NULL 和 nullptr 的区别？

+ C++ 中 struct 和 class 的区别？ C 中 struct 和 C++ struct 的区别？

+ final 和 override 关键字？

+ 值传递、指针传递、引用传递的区别和效率？

+ auto、decltype 和 decltype(auto) 的用法？

+ C++ 四种强制转换 reinterpret_cast/const_cast/static_cast/dynamic_cast 用法？

+ 将引用作为函数参数的好处是什么？

+ 数组和指针的区别？

+ static_cast 比 C 语言的转换强在哪里？

+ hello.c 的编译过程？（静态链接、动态链接）

+ 介绍几种典型的锁？

+ C++ 左值引用、右值引用？

----

**重载、虚函数**

+ C++ 中重载、重写（覆盖）、和隐藏的区别？

+ 什么是虚函数？虚函数和纯虚函数的区别？

+ 基类的虚函数表存储在内存的什么位置（哪个区）？虚表指针 vptr 的初始化位置？

+ 静态类型和动态类型、静态绑定和动态绑定的介绍

+ 引用是否能实现动态绑定，为什么可以实现？

+ C++ 指针参数传递和引用参数传递有什么区别？底层原理是什么？

+ 重载运算符？

+ 函数中有重载时，函数的匹配原则和顺序是什么？

+ 什么是隐式转换，如何消除隐式转换？

+ volidate 关键词作用是什么？

+ 你什么时候用指针当参数，什么时候用引用当参数，为什么？

+ 静态函数能定义为虚函数吗？常函数呢？

+ 虚函数的代价？

+ 什么是纯虚函数，与虚函数的区别？

+ 用 C 实现 C++ 继承？

+ 动态编译和静态编译？

----

**类、对象、继承**

+ 介绍面对对象的三大特性，并举例说明？

+ 是什么是类的继承？

+ 类成员初始化方式？构造函数的执行顺序？为什么成员初始化类列表会快一些？

+ 拷贝初始化和直接初始化的区别？

+ 什么是成员列表初始化？什么时候必须要用初始化成员列表？

+ 类的对象存储空间？

+ 类什么时候会析构？

+ C++ 有哪几种构造函数？

+ 构造函数的几种关键字？

+ 为什么析构函数一般写成虚函数？

+ 构造函数能否声明为虚函数或者纯虚函数，析构函数呢？ （构造函数为什么不能是虚函数，析构函数为什么要是虚函数）

+ 析构函数的作用？以及是如何起作用的？

+ 构造函数和析构函数可以调用虚函数吗？为什么？（构造函数或者虚构函数中可以调用虚函数吗？）

+ 构造函数和析构函数的执行顺序，以及它们的内部都做了什么？

+ 虚析构函数的作用？父类的析构函数是否要设置为虚函数？

+ 构造函数和析构函数可否抛出异常？

+ 构造函数一般都定义为虚函数的原因？

+ 构造函数、拷贝构造函数和赋值操作符的区别？

+ 拷贝构造函数和赋值运算符重载的区别？

+ C++ 多态是如何实现的？

+ 浅拷贝和深拷贝的区别？

+ 构造函数、析构函数、虚函数是否能声明为内联函数？

+ public/protected/private 区别和访问、继承权限？

+ 什么时候调用拷贝构造函数？

+ C++ 中类数据成员和成员函数内存分布情况？

+ 什么是 trivial destructor？

+ 什么是对象复用？什么是零拷贝？

+ 移动构造函数？

+ 关于 this 指针？
    - this 指针何时创建的？
    - this 指针存放在哪里？堆、栈、全局变量、还是其他？
    - this 指针是如何传递类中的函数的？绑定还是函数参数的首参数就是 this 指针？那么 this 指针是如何找到“类实例后函数的”？
    - this 指针是如何访问类中的变量的？
    - 只有获得一个对象后，才能通过对象使用 this 指针。如果我们知道一个对象 this 指针的位置，可以直接使用吗？
    - 每个类编译后，是否创建一个类中函数保存函数指针，以便用来调试函数？

+ 在成员函数中 delete this 会出现什么问题？对象还可以使用吗？

+ this 指针调用成员变量时，堆栈会发生变化吗?

+ 什么是虚拟继承？

+ 类是如何实现只能静态分配和动态分配的？

+ 如果想将某个类作为一个基类，为什么该类必须定义而非声明？

+ 什么情况会自动生成默认构造函数？

+ 抽象基类为什么不能创建对象？

+ 继承机制中对象直接如何转换？指针和引用之间如何转换？

+ C++ 的组合和继承有什么区别和优缺点？

+ C++ 类成员的访问权限和继承权限问题？

+ 静态成员和普通成员是什么？

+ 虚函数内存结构，棱形继承的虚函数内存结构呢？

+ 多继承的优缺点，作为一个开发者如何看待多继承？

+ 如果有一个空类，它会默认添加什么函数？

+ 空类大小是多少？

+ 拷贝构造函数为什么必须引用而不能传值？

+ 如何设计一个类来计算子类的个数？

+ 类对象大小受到哪些因素影响？

+ 什么时候用到合成构造函数？

+ 什么时候用到合成拷贝构造函数？

+ 成员初始化列表会在什么时候用到？它的调用过程是什么？

+ 构造函数的执行顺序是什么？

+ 一个类中的全部构造函数的扩展过程是什么？

+ 哪些函数不能是虚函数?
 
+ 如何阻止一个类被实例化的方法？

+ 如何禁止程序自动生成拷贝构造函数？

+ 成员函数中 memset(this, 0, sizeof(this)) 会发生什么？

+ 为什么友元函数必须在内部声明？

---

**独立特性（范式编程，异常机制、元编程、STL标准库）**

+ 迭代器失效的情况？

+ C++ 异常处理方法？（C++ 是如何处理多个异常的）

+ C/C++ 类型安全？

+ C++ 模板是什么，底层是如何实现的？

+ 模板函数和模板类的用法？

+ 智能指针的作用、原理、常用的智能指针及实现？

+ auto_ptr 作用？

+ 智能指针的循环引用？

+ 智能指针管理内存资源，RAII是什么？

+ 手写实现智能指针类？

+ 智能指针出现循环引用怎么解决？

+ C++ 11 有哪些新特性？

+ 模板类和模板函数的区别？

+ 为什么模板类一般都放在一个 .h 文件中？

+ 迭代器 ++it、it++ 哪个好，为什么？

+ 模板和实现写一个文件中可不可以？为什么？

+ C++ 中标准库是什么？

+ 写一个比较大小的模板？

+ STL 的 hashtable 实现

+ STL 的 traits 技法？

+ STL 的两级空间配置器？（一级配置器，二级配置器，一级分配器，二级分配器）

+ vector 和 list 的区别与应用，怎么找到某 vector 和 list 的倒数第二个元素?

+ STL 中 vector 删除其中的元素，迭代器如何变化？为什么是两倍扩容？释放空间？

+ STL 容器内部删除一个元素？

+ STL 迭代器如何实现？

+ map、set 如何实现的，红黑树是怎么能够同时使用这两种容器的？为什么使用红黑树？

+ 如何在共享内存中使用 STL 标准库？

+ map 插入有几种方式？

+ STL 的 unordered_map(hash_map) 和 map 的区别？hash_map 如何解决冲突和扩容？

+ vector 越界访问下标，map 越界访问下标？ vector 删除元素会不会释放空间？

+ map 中的 [] 和 find 有什么区别？

+ STL 中的 list 和 queue 区别？

+ STL 的 allocator deallocator

+ STL 的 hash_map 扩容发生了什么？

+ 常见的容器性质总结？

+ vector 的增加删除是怎么做到的，为什么是 1.5 或者是 2？

+ 说一下 STL 每种容器对于的迭代器？

+ STL 的 vector 实现

+ STL 的 slist 实现

+ STL 的 list 实现

+ STL 的 deque 实现

+ STL 的 stack 和 queue 实现

+ STL 的 heap 实现

+ STL 的 priority_queue 实现

+ STL 的 set 实现

+ STL 的 map 实现

+ set 和 map 的区别，multimap 和 multiset 的区别？

+ STL 的 unordered_map 和 map 的区别和应用场景？

+ hashtable 中解决冲突的方法？
----









