# C和C++的区别
    [C和C++的区别](https://www.cnblogs.com/wanghao-boke/p/14613495.html)
    
    + 基础语法没用太大的区别？
    + C++ 多出一下语法和关键字，引用、new/delete、auto、explicit等
    + C++ 多了重载和虚函数
    + C++ 面向对象的部分，类、继承、对象
    + C++ 和 C 的设计思想和应用场景。处于对内存和执行效率的考虑，C优点是精简和高效，多用于操作系统和内核驱动；C++ 设计之初的目的就是把 C 繁杂的实现过程抽象成类，并且进行实例化管理，更适用做大型软件。C 更注重逻辑实现，C++ 更适合程序的整体设计。

# 基础语法

## C++ 从代码到可执行函数经历了什么？（预编译、编译、汇编、链接（静态链接、动态链接））
    + 预编译：处理以 # 号开头的预编译命令，#define、#if、#include，删除注释、添加行号和文件标识等；
    + 编译：把预编译生成的 xxx.i 或者 xxx.ii 文件进行一系列的词法分析、语法分析、语义分析及优化之后生成相应的汇编文件；
    + 汇编：把汇编代码翻译成机器码文件，生成 xxx.o 或者 xxx.obj 文件
    + 链接：静态链接、动态链接
    + 可执行程序

---

## main执行前和执行后的代码可能是什么?
    ### main 函数执行之前，注意是为了初始化系统相关资源：
        + 设置栈指针；
        + 初始化静态 static 变量和 global 全局变量，即 .data 段的内容；
        + 将未初始化部分的全局变量赋初始值，即 .bss 内容（数值型 short、int、long 为 0，bool 型为 false、指针为 null 等等）
        + 全局对象初始化，在 main 之前调用构造函数，这是可能执行前的一些代码；
        + 将 main 函数参数 argc、argv 等传递给 main 函数，然后才真正运行 main 函数；
        + attribute(constructor) //构造函数
    
    ### main 函数执行之后：
        + 全局的析构函数会在 main 执行；
        + 可以注册一个 atexit 函数，它会在 main 之后执行；
        + attribute((destructor))
        
---

## C++ 中 struct 和 class 的区别？ 
    1. C++ 的 struct 和 calss 的主要区别是成员默认权限不同，struct 默认公有的，class 默认私有的；

---

## C 中 struct 和 C++ struct 的区别？

1. C 中 struct 是用户自定义数据类型（UDT）；C++ 是struct 抽象数据类型（ADT），支持成员函数的定义（C++ 中的 struct 能继承，能实现多态）
2. C 中 struct 是没有权限的设置，且 struct 中只能是一些变量的集合体，可以封装数据却不能隐藏数据，而且成员不能是函数；
3. 在 C++ 中 struct 增加了访问权限，且和类一样有成员函数，成员访问默认说明符是 public（为了和 C 兼容）
4. struct 作为类的一种特例用来自定义数据结构，一个结构标记声明后，在 C 中必须在结构标记前加上 struct，才能做到结构类型名（typdef struct class{};）；C++ 中结构体标记（结构体名）可以直接作为结构体类型名使用，此外结构体 struct 在 C++ 中被当作类的一种特例；

---

## 形参和实参的区别？
    + 新参变量只有在被调用的时候才会分配内存单元，在调用结束时即可释放内存单元，因此，形参只有在函数内部有效，函数调用结束返回主调函数后则不能使用该形参变量
    + 实参可以是常量、变量、表达式、函数等，无论实参是何种类型的量，在进行函数调用时，他们都必须是确定的值，以便把这些值传递给形参，因此应预先用赋值、输入等方法使实参获得确定的值
    + 实参和形参在数量上，类型上、顺序上应该保持严格一致，否则会发生“类型不匹配错误”
    + 函数调用中发生的数据传送是单向的，即只能把实参的值传递给形参，而不能把形参的值反向的传递给实参，因此在函数调用过程中，形参的值发生变化不会影响到实参
    + 当形参和实参不是指针类型时，在函数运行时，形和参实参是不同的变量，他们在内存中位于不同的位置，形参将实参传递过来的内容复制一份，而在该函数运行结束时形参被释放，而实参内容不会改变
    
---

## 结构体内存对齐问题？
   + 结构体成员每个成员的相对结构体首地址的偏移量是对齐参数的整数倍，首位元素是对齐参数的 0 倍；
   + 结构体变量所占空间大小是对齐参数的整数，如有需要在最后一个成员末尾填充字节达到该要求；
   
---

## 内存对齐的理解以及理解？
    + 分配内存的顺序是按照变量声明的顺序
    + 每个变量相对于起始位置的偏移量必须是该变量类型的整数倍，不是整数倍的空出内存，直到偏移量为整数倍为止
    + 最后整个结构体的大小必须是里面变量类型最大值的整数倍
    
---

## 如何获取结构体成员相对于结构体开头的字节偏移量？
    (unsigned long)(&(type.Member)) - (unsigned long)(&(type))
    
---

## 判断结构体比较是否相等？
    + 重载 “==” 操作符
    + 对结构体变量一个个比较
    + 指针直接比较，如果保存的是同一个实例，则两个指针保存的地址是一样的
    
---

## 指针和引用的区别？
    + 指针是一个实体，需要分配内存；引用只是变量的别名，不需要分配内存空间；
    + 引用在定义时候必须进行初始化，并且不能改变；指针在定义的时候不一定要进行初始化，并且指向的空间可变；
    + 有多级指针，但是没有多级引用。只能有以及引用；
    + 指针和引用的自增运算结果不一样；（指针是指向下一个空间，引用是引用的变量值加 1 ）；
    + sizeof 引用得到的结果是引用所指向的变量（对象）的大小；sizeof 指针得到的指针本身的大小；
    + 使用指针前最后做类型检查，防止野指针的出现；
    + 引用底层是用指针实现的；
    + 作为参数时，传指针实际上是传值，传递的值是指针的地址；传引用的实质是传地址，传递的是变量的地址；
    
---

## 值传递、指针传递、引用传递的区别和效率？
+ 值传递：有一个形参向函数所属的栈拷贝数据的过程，如果值传递的对象是类对象，或是大的结构体对象，将耗费一定的时间和空间。（传值）
+ 指针传递：同样有一个形参向函数所属的栈拷贝数据的过程，但拷贝的数据是一个固定为 4 字节的地址。（传值，传递的是地址值）
+ 引用传递：同样有上述数据的拷贝过程，但是针对的地址，相当于为该数据所在的地址起了一个别名

+ 从效率上说，指针传递和引用传递的效率要比值传递的效率要高，一般主张使用引用传递，代码逻辑上更加紧凑，清晰；

---

## 将引用作为函数参数的好处是什么？
+ 传递引用给函数与传递给指针的效果是一样的：此时被调函数的形参就成为原来主调函数的实参变量或者对象的一个变量的一个别名使用，所以在被调函数中对形参变量的操作就是对其目标对象（在主调函数中）的操作；
+ 使用引用传递函数的参数，在内存中没有产生实参的副本，它是直接对实参操作；
    - 使用一般变量传递函数的参数，当发生函数调用时，需要给形参分配内存单元，形参变量是实参变量的副本；
    - 如果传递的是

---

## 在汇编层面上解释一下引用？
    + 引用在底层是用指针，更准确的是用地址实现的
    + 但从高级语言一级来说，指针和引用没有关系，引用就是另一个变量的别名
    + 引用占据一个内存空间，存储一个地址，一般是4个字节
    
---

## const 的用法？（常量指针和指针常量的区别，C++ 中顶层 const 和底层 const）
    const 修饰变量、数组、指针、函数参数、函数返回值、引用都是对修饰对象的声明为只读属性，不允许修改 const 所修饰的对象
    const 修饰类成员函数、类限制成员函数和类对类成员变量的修改
   
   常量指针：是 const 修饰的常量的指针，int const *p/const int* p，*p的值不可变
   指针常量：是 const 修饰的不能改变指向的指针，int* const p，p值不可变
   
---

## static 的作用？（静态变量什么时候初始化）
    ### 不考虑类时：
        1. 修饰全局变量作用是隐藏：修饰全局变量和函数时隐藏它们的全局可见性，限制它们只能在该文件所在的编译模块中使用；
        2. 修饰局部变量的作用是改变局部变量的生存周期：静态变量在函数内定义，始终存在，只进行一次初始化。作用区域与局部变量相同，生存周期等同于程序的生存周期；
        3. 默认初始值：static 修饰的变量没有初始化的话存储在全局未初始化区域，存储在该区域的变量统一默认为 0；

    ### 考虑类时：
        4. 修饰类成员变量：该变量只与类关联，不与类的对象关联。定义是要分配空间，不能在类声明中初始化，必须在类定义外部初始化，初始化时不必标识为 static ；可以被非 static 成员函数任意访问；
        5. 修饰成员函数：该函数没有 this 指针，无法访问类的非 static 成员函数和非 static 成员变量；不能被声明为 const、虚函数、volatile；可以被非 static 成员函数任意访问；

---

## strlen 和 sizeof 的区别？
    1. sizeof 是运算符，在编译时就获得了结果；strlen 是字符处理的库函数；
    2. sizeof 的参数可以是任何数据的类型或任何数据（sizeof参数不退化）；strlen 的参数只能是字符指针且结尾是 '\0' 的字符串；
    3. 因为 sizeof 值在编译时就已经得到了，所以它不能用来得到动态分配存储空间的大小；

---

## extern"C" 的用法？
    + 功能：extern "C" 的作用是为了实现 C/C++ 混编；
    + 原因：C++ 为了支持重载功能，编译器在编译阶段会对函数名进行“再次重命名”-由原有的函数名和各个参数的数据类型构成一个新的函数名；但是 C 的编译器不支持重载，也就没有了这步额外的步骤；这个结果也就意味着在 C 和 C++ 进行混合编译时，会造成编译器在程序链接阶段无法找到函数具体的实现，导致链接失败。
    + 解决方法：而 extern "C" 就是为了解决这个问题的，extern "C" 修饰的变量和函数都是按照 C 语言方式进行编译和链接的；

---

## 宏定义（define）和 typedef 的区别？
    + 宏主要是用于定义常量及书写复杂的内容；typedef 主要是定义类型别名；
    + 宏替换发生在预处理阶段，属于文本插入替换；typedef 是编译的一部分；
    + 宏不检查类型； typedef 会检查数据类型；
    + 宏不是语句，不在结尾处加分号； typedef 是语句，要加分号标识结束；
    + 注意对指针的操作；typedef char *p_char 和 define p_char char* 差别巨大

---

## 宏定义（define）和函数的区别？
    + 宏定义在预编译期间完成替换，之后被替换的文本参与编译，相当于直接插入了代码，不存在调用步骤，执行速度更快；函数调用在运行时需要跳转到具体调用函数；
    + 宏定义属于在结构中插入代码，没有返回值；函数调用具有返回值；
    + 宏定义参数没有类型，不进行类型检查；函数参数具有类型，需要检查类型；
    + 宏定义在最后不需要加分号；

---

## 宏定义（define）和 const 的区别？
    ## 编译阶段
        + define 在编译的预处理阶段起作用，而const 在编译、运行时起作用
    ## 安全性
        + define 只做替换，不做类型检查和计算，也不求解，容易产生错误，一般最好加上一个大括号包含住所有内容，不然很容易出现错误；
        + const 常量有数据类型，编译器可以对其进行类型安全检查
    ## 内存占用
        + define 只是将宏名称进行替换，在内存中会产生多份相同的备份；const 在程序运行时只有一份备份，且可以执行常量折叠，能将复杂的表达式计算出结果放到常量表中；
        + 宏定义的数据没有分配内存，只是插入替换；const 定义的变量只是值不能改变，但要分配内存空间；

---

## 宏定义（define）和内联函数的区别？
    + define 是关键字，inline 是函数
    + 宏定义在预处理阶段进行文本替换，inline 函数在编译阶段进行替换
    + inline 函数有类型检查，相比于宏定义更安全

---

## 变量声明和定义的区别？（声明和定义的区别？）
    + 声明仅仅是把变量声明的位置提供给编译器，并不分配内存空间；定义是要在定义的地方为其分配存储空间；
    + 相同变量可以在多处声明（外部extern），但只能在一处定义；

---

## 不同的指针类型？（数组名和指针， a 和 &a 之间的区别）
    ### 数组名和指针
        + 二者都可以通过增减偏移量来访问数组中的元素；
        + 数组名不是真正意义上的指针，可以理解为常指针，所以数组名没有自增自减的操作；
        + 当数组名当作形参传递给调用函数后，就退化成了一般指针了，也就有了自增自减的操作了。但sizeof运算符不能再得到原数组的大小了；

---


## 野指针和悬空指针？
    + 都是指向无效（无效是指“不安全不可控”的）内存区域的指针，访问行为将会导致为定义行为;
    + 野指针指的是没有初始化的指针；悬空指针是指向的区域已经被释放了的指针;
    + 解决方案：
        - 野指针：定义指针变量要及时初始化，要么置空；
        - 悬空指针：指针释放操作后要及时置空；

---

## 初始化和赋值的区别？
    + 初始化的发生过程在编译阶段，赋值发生在函数或者程序运行时；
    + 对于基本数据类型来说，两者的差别不大，但是对于用户自定义数据类型区别很大：
        - 对于初始化操作，程序调用了类的构造函数；
        - 对于赋值操作，程序需要重载 = 号，调用拷贝构造函数

---

## 什么是内存池，如何实现？（待完善）
    + 一次性向操作系统申请一大堆内存，在此之上构建需要的对象，用完之后统一返还给操作系统。这样做最大的好处是避免了频繁的 new/delete 开销和带来的内存碎片问题。

---

## 什么是内存泄漏？如何检查和避免？（内存泄露后果，如何检测，解决方案？）（待完善）
    + 内存泄漏一般指堆内存泄漏。用动态存储分配函数动态开辟的空间，在使用完毕后未释放，结果导致一直占据该内存单元。直到程序结束；
    + 避免内存泄漏的几种方法：
        1. 计数法：使用一个变量来记录内存申请和释放的次数，在使用内存分配函数时加一，在释放内存时减一，在程序执行完检测该变量的值，如果不为0则表示内存泄漏；
        2. 一定要把基类的虚构函数声明为虚函数；
        3. 对象数组的释放要用到 delete[]；
        4. 有 new 就要有 delete， 有 malloc 就要有 free

--

## C++ 函数调用压栈过程？
    + 当函数从入口函数 main 开始执行时，编译器会将我们操作系统状态的运行状态，main 函数的返回地址，main 的参数，main 函数中的变量 依次进行压栈；
    + 当 main 函数开始调用函数 func 时，编译器此时会将 main 函数的运行状态进行压栈，再将 func 函数的返回地址、func 函数的参数从右向左、func 函数定义变量依次压栈；
    + 当 func 函数调用 func2 函数时，编译器会将调用 func 函数的运行状态压栈，再将 func2 函数的返回地址、func2 函数的参数从右向左依次压栈；

    总结：函数压栈的顺序是当前程序运行的运行状态、调用函数的返回地址、调用函数的参数从右向左、调用函数中定义变量依次压栈。

--

## C++ 将临时变量作为返回值时的处理过程？
    函数调用结束后，函数返回值被临时存储到寄存器中，此时该值就和堆栈没有关系了。当函数退出时，临时变量可能被销毁，但被保存到寄存器的返回值和临时变量的生命周期已经没有关系了。

    补充:C 语言中规定，16bit程序中，返回值保存在 ax 寄存器中，32bit 程序中，返回值保持在 eax 寄存器中，如果是 64bit 返回值，edx 寄存器保存高 32bit，eax 保存低 32 bit

---

## 全局变量和局部变量有什么区别？（全局变量和 static 变量区别？）
+ 生命周期不同：全局变量随主程序创建而创建，随主程序销毁而销毁；局部变量在局部函数内部，甚至是局部循环体内部存在，退出时即被销毁；
+ 使用方式不同:通过声明后全局变量在程序各个部分都可以用到；局部变量分配在堆栈上，只能局部使用；
+ 内存分配位置不同：全局变量分配在全局数据段并且在程序运行时被加载，局部变量分配在堆栈中，使用时才会被分配内存空间。

### 全局变量和 static 变量的区别
    + 全局变量的作用域是整个整个源程序，静态全局变量的作用域仅限本文件，静态局部变量的作用域仅限局部函数中；
    + 当整个源程序是由一个文件组成的话，静态全局变量和全局变量没有根本差别
        
---

## 函数指针是什么？
+ 概念：函数指针指向的是特殊的数据类型，函数的类型是由其返回的数据类型和其参数列表共同决定的，而函数名称不是其类型的一部分；
+ 函数指针的声明方法： 
    - int (*pf)(const int&, const int&); 其中pf就是一个函数，指向所有返回值为 int 型，并带有两个 const int& 参数的函数
+ 函数指针的作用：函数和数据项很相似，函数也有指针，我们希望在同一个函数通过使用相同的参数在不同的时间产生不同的效果；
+ 函数指针的使用：一个函数名就是一个指针，它指向函数的代码。一个函数的地址就是该函数的进入点，也是调用函数的地址。函数调用可以通过函数名，也可以通过指向函数的指针来调用。函数指针还允许将函数作为变元传递给其他函数；
    
---

## 回调函数的作用？
+ 作用就是为了分离代码，降低程序的耦合性

---




## 数组和指针的区别？

## 函数调用过程中栈的变化，返回值和参数变量哪个先入栈？
+ 先定义的变量先入栈，先是函数形参入栈，然后是按照临时变量定义的顺序入栈，返回值和参数变量入栈的顺序是根据定义顺序，谁先被定义谁先入栈；

---

## printf 函数实现原理？（待完善）

## lambda函数的全部知识？（待完善）

## 将字符串 “hello world” 从开始到打印屏幕上的全过程？（）

## cout 和 printf 有什么区别？
+ cout 是 C++ 标准库的控制台输入流类，需要配合 << 使用，而 printf 是 C 的控制台输出函数；
+ printf 是变参函数，没有类型检查，不安全；cout 是通过运算符重载实现的，较为安全；
+ printf 只能输入基本数据类型，cout 可以通过重载函数的方式去实现自定义类的输出；

---

## ifdef、endif 代表着什么？
+ ifdef、endif 实现了条件编译的需求；
+ 使用 #define、#ifndef、#ifdef、#endif 避免头文件的重定义
    
---

## strcpy 和 memcpy 的区别？
+ 复制内容不同。strcpy 只能复制字符串，而 memcpy 可以复制任意内容，例如字符数组、整型、结构体、类；
+ 复制的方法不同。strcpy 不需要指定长度，它遇到'\0'时自动结束，容易产生溢出；而 memcpy 根据第三个参数决定复制的长度；
+ 用途不同。复制字符串时一般使用 strcpy，复制其他类型时使用 memcpy；

---

## 程序在执行 int main(int argc, char *argv[]) 时的内存结构？
+ 参数的含义是程序在命令行下运行时，需要输入 argc 个参数，每个参数都是 char 类型输入，依次存 argv[[] 在数组中，所有参数在指针 char* 指向的内存中，数组中元素个数是 argc 个，第一个参数为程序的名称

---

## const char* 和 string 之间是什么关系？
+ string 是 C++ 标准库，封装了对字符串的操作，const char* 是一个指向字符常量的指针。
+ 其中 char* 、const char* 和 string 可以相互转化

---

## strcpy、sprintf、memcpy 这三个函数的不同之处？
+ 操作对象不同：stcpy的两个操作对象是字符串；sprintf 操作源可以是多种数据类型，目的操作对象是字符串；memcpy的两个对象

---

## Debug 和 release 的区别？
+ Debug(调试版本)，包含调试信息，容量要比 release 大，没有进行优化，生成文件除了 .exe 或者 .dll 外还有一个 .pdb，该文件记录了代码中断点等调试信息；
+ Release（发布版本）：编译时对应用程序进行优化，使代码在运行速度和代码大小上都是最优的。不生成 .pdb 文件
+ 实际上，Debug 和 Release 没有本质的区别，它们只是一组编译选项的集合，编译器只是按照预定的选项行动。实际上我们也可以对这些选项进行修改，从而得到优化后的调试版本或者带有跟踪语句的发布版本；

---

## main 函数的返回值有什么考究之处的？
+ 程序运行过程入口点 main 函数，即 main() 函数返回值类型返回值必须是 int，这样返回值才能传递给激活者(如操作系统)表示程序正常退出；
+ main(int args, char **argv) 参数的传递一般使用 getopt() 函数去处理；

---

## strcpy 函数和 strncpy 函数的区别？哪个更安全？
+ 函数原型：
    ```
    char *strcpy(char* strDest, const char* strSrc)
    char *strncpy(char* strDest, const char* strSrc, int pos)
    ```
+ strcpy 函数：如果 dest 所指的内存空间不够大，可能会造成缓冲溢出（buffer overflow）的错误；strncpy函数： 用来复制源自符的前 n 个字符，src 和 dest 所指的内存区域不能重叠，且 dest 必须有足够的空间放置 n 个字符
+ 如果 sizeof(dest) > pos > sizeof(strSrc),则将 strSrc 全部拷贝到目标中，尾后自动加上 '\0'；如果 pos < sizeof(strSrc) ，则将源字符串按指定查昂都拷贝到目标字符串中，不包括 '\0'；如果 pos > sizeof(dest)，运行报错；

---

## 一致性哈希？
+ 一致性哈希是一种哈希算法，就是在移除或者增加一个结点时，能够尽可能小的改变已存在 key 的映射关系；一致性哈希将整个哈希值空间组织成一个虚拟的圆环，一致性哈希的基本思想就是使用相同的hash算法将数据和节点都映射到一个圆形哈希空间中，按照顺时针的方向，将数据绑定到离它最近的一个节点上去； 

------

**关键字**

# malloc 和 free 实现的原理？
+ malloc/free 函数在底层是由 brk、mmap、munmap 这些系统调用实现；
+ malloc 是从堆中申请内存。操作系统中有一个记录空闲内存地址的链表，操作系统收到程序的申请时，会遍历该链表，然后找到第一个空间大于所申请空间的堆节点，然后把该节点从链表中删除，并把该节点的空间分配给程序；

---

# malloc、realloc、calloc 区别？
+ calloc 会对申请的空间初始化为0， 但是其他两个不会；
+ malloc 申请的空间必须用 memset 初始化；
+ realloc 是对已有的内存空间进行调整，可能会重新开辟内存空间并且释放原有内存空间。

---

# new/delete 和 malloc/free 的区别？（new 和 malloc 的区别？）
+ 类型不同：new/delete 是关键字，需要编译器支持；malloc/free 是库函数，需要头文件支持；
+ 参数不同：new 申请内存分配时无需指定内存块大小，编译器会根据类型信息自行计算。而 malloc 则需要显示地指出所需内存的大小；
+ 返回结果不同：new 内存申请成功后返回时对象类型的指针；malloc 返回的是 void*，需要通过强制类型转换将 void* 转换成需要的类型；
+ 内存分配失败返回结果不同：new 内存返回失败会抛出异常，malloc 内存分配失败返回 NULL；
+ 申请用户自定义类过程不同：new 会调用 operator new 函数，申请足够的内存，然后调用该类型的构造函数，进行初始化成员变量，最后返回自定义类型指针，delete 会先调用析构函数，然后再调用 operator delete 函数释放内存。malloc/free 只能实现动态的申请和释放内存，无法强制要求对其做自定义类型对象构造和析构函数。

---

## new 和 delete 是如何实现的？（delete 是如何知道要释放内存的大小？）
+ new 简单类型直接调用 operator new 分配内存；
+ new 复杂结构时表达式会调用 operator new(operator new[]) 函数，分配一块足够大的、原始的、未命名的内存空间；
+ 编译器运行相应的构造函数构造这些对象，并为其传入初始值；
+ 对象被分配了空间并沟站完成，返回一个指向该对象的指针；

+ delete 简单数据类型时只是调用了 free 函数，且此时 delete 和 delete[] 等同；
+ delete 复杂类型时先调用析构函数，再调用 operator delete；

---

## malloc 申请的空间能用 delete 释放吗？
    理论上来说是可以的，但是由于 malloc/free 操作对象都是明确大小的，而且是不能用在动态类上，与此同时 new 和 delete 会自动进行类型检查和大小，malloc/free 不能执行构造函数和析构函数，所以不建议使用 delete 去释放 malloc 分配的空间，因为这样不能保证每个 C++ 程序运行时都正常；

---

## delete 和 delete [] 的区别？（delete、delete []、alloctor 有什么作用？）
+ delete 和 delete[] 的区别主要是在于对非内部数据对象的处理上，delete 只能调用一次非内部数据对象的析构函数，而 delete[] 会调用数组的每一个成员的析构函数；
+ new 的机制是将内存分配和对象构造组合在一起，delete 也是将对象的析构函数和内存释放组合在一起了，allocator 是将这两部分分开了，allocator 申请一部分内存，但是不进行初始化，只有当需要的时候才进行初始化操作；

---

## C++ 有几种类型的 new？
+ palin new:最常用的 new 函数，申请空间失败抛出异常
+ nothrow new：申请失败返回 NULL
+ placement new：在一块已经开辟的空间上构造对象，需要显示的调用析沟函数去销毁，不能使用 delete，否则可能会造成内存泄漏或者运行错误

---

## C++ 中 NULL 和 nullptr 的区别？
+ NULL 是宏定义，而 nullptr 是关键字；
+ C 语言中的 NULL 被定义为 (void*)0, C++ 中 NULL 被定义为 0；所以在传入 NULL 参数时会把 NULL 当作整数零来看待，为了和调用参数时指针函数区分开，引入 nullptr
+ nullptr 可以明确的区分整型和指针类型，根据环境自动的转换成相应的指针类型，但不会被转换成任何整形，所以不会造成参数传递错误；

---    

## final 和 override 关键字？
+ override 指定了子类的这个虚函数是重写父类的，如果该函数父类没有或者没有被声明为虚函数，是要被报错的。
+ final 阻止某个类被继承或者某个虚函数被重写；

---

## auto、decltype 和 decltype(auto) 的用法？
+ auto： C++ 新标准引入 auto 说明符，用它就能让编译器替我们去分析表达式所属类型。auto 让编译器通过初始值进行类型推演，从而获得定义变量的类型，auto 必须要有初始值
+ decltype：选择并返回操作数的数据类型，在此过程中，编译器只是分析表达式并得到它的类型，并不去计算实际的表达式的值。
+ decltype(auto):C++14 新增的类型指示符，可以用来生命变量以及指示函数返回类型。在使用时会将"="号左边的表达式替换调 auto，再根据 decltype 的语法规则来确定类型；

---

## C++ 四种强制转换 reinterpret_cast/const_cast/static_cast/dynamic_cast 用法？
+ reinterpret_cast：用于类型之间进行强制转换；
+ const_cast：用来修改类型的 const 和 volatile 属性；
+ static_cast：派生类指针或引用转换成基类；
+ dynamic_cast：基类向派生类转换比较安全，反之不安全，但是转换失败会返回 nullptr，以此来做判断

---

+ static_cast 比 C 语言的转换强在哪里？

+ hello.c 的编译过程？（静态链接、动态链接）

+ 介绍几种典型的锁？

+ C++ 左值引用、右值引用？

----

**重载、虚函数**

+ C++ 中重载、重写（覆盖）、和隐藏的区别？

+ 什么是虚函数？虚函数和纯虚函数的区别？

+ 基类的虚函数表存储在内存的什么位置（哪个区）？虚表指针 vptr 的初始化位置？

+ 静态类型和动态类型、静态绑定和动态绑定的介绍

+ 引用是否能实现动态绑定，为什么可以实现？

+ C++ 指针参数传递和引用参数传递有什么区别？底层原理是什么？

+ 重载运算符？

+ 函数中有重载时，函数的匹配原则和顺序是什么？

+ 什么是隐式转换，如何消除隐式转换？

+ volidate 关键词作用是什么？

+ 你什么时候用指针当参数，什么时候用引用当参数，为什么？

+ 静态函数能定义为虚函数吗？常函数呢？

+ 虚函数的代价？

+ 什么是纯虚函数，与虚函数的区别？

+ 用 C 实现 C++ 继承？

+ 动态编译和静态编译？

----

**类、对象、继承**

+ 介绍面对对象的三大特性，并举例说明？

+ 是什么是类的继承？

+ 类成员初始化方式？构造函数的执行顺序？为什么成员初始化类列表会快一些？

+ 拷贝初始化和直接初始化的区别？

+ 什么是成员列表初始化？什么时候必须要用初始化成员列表？

+ 类的对象存储空间？

+ 类什么时候会析构？

+ C++ 有哪几种构造函数？

+ 构造函数的几种关键字？

+ 为什么析构函数一般写成虚函数？

+ 构造函数能否声明为虚函数或者纯虚函数，析构函数呢？ （构造函数为什么不能是虚函数，析构函数为什么要是虚函数）

+ 析构函数的作用？以及是如何起作用的？

+ 构造函数和析构函数可以调用虚函数吗？为什么？（构造函数或者虚构函数中可以调用虚函数吗？）

+ 构造函数和析构函数的执行顺序，以及它们的内部都做了什么？

+ 虚析构函数的作用？父类的析构函数是否要设置为虚函数？

+ 构造函数和析构函数可否抛出异常？

+ 构造函数一般都定义为虚函数的原因？

+ 构造函数、拷贝构造函数和赋值操作符的区别？

+ 拷贝构造函数和赋值运算符重载的区别？

+ C++ 多态是如何实现的？

+ 浅拷贝和深拷贝的区别？

+ 构造函数、析构函数、虚函数是否能声明为内联函数？

+ public/protected/private 区别和访问、继承权限？

+ 什么时候调用拷贝构造函数？

+ C++ 中类数据成员和成员函数内存分布情况？

+ 什么是 trivial destructor？

+ 什么是对象复用？什么是零拷贝？

+ 移动构造函数？

+ 关于 this 指针？
    - this 指针何时创建的？
    - this 指针存放在哪里？堆、栈、全局变量、还是其他？
    - this 指针是如何传递类中的函数的？绑定还是函数参数的首参数就是 this 指针？那么 this 指针是如何找到“类实例后函数的”？
    - this 指针是如何访问类中的变量的？
    - 只有获得一个对象后，才能通过对象使用 this 指针。如果我们知道一个对象 this 指针的位置，可以直接使用吗？
    - 每个类编译后，是否创建一个类中函数保存函数指针，以便用来调试函数？

+ 在成员函数中 delete this 会出现什么问题？对象还可以使用吗？

+ this 指针调用成员变量时，堆栈会发生变化吗?

+ 什么是虚拟继承？

+ 类是如何实现只能静态分配和动态分配的？

+ 如果想将某个类作为一个基类，为什么该类必须定义而非声明？

+ 什么情况会自动生成默认构造函数？

+ 抽象基类为什么不能创建对象？

+ 继承机制中对象直接如何转换？指针和引用之间如何转换？

+ C++ 的组合和继承有什么区别和优缺点？

+ C++ 类成员的访问权限和继承权限问题？

+ 静态成员和普通成员是什么？

+ 虚函数内存结构，棱形继承的虚函数内存结构呢？

+ 多继承的优缺点，作为一个开发者如何看待多继承？

+ 如果有一个空类，它会默认添加什么函数？

+ 空类大小是多少？

+ 拷贝构造函数为什么必须引用而不能传值？

+ 如何设计一个类来计算子类的个数？

+ 类对象大小受到哪些因素影响？

+ 什么时候用到合成构造函数？

+ 什么时候用到合成拷贝构造函数？

+ 成员初始化列表会在什么时候用到？它的调用过程是什么？

+ 构造函数的执行顺序是什么？

+ 一个类中的全部构造函数的扩展过程是什么？

+ 哪些函数不能是虚函数?
 
+ 如何阻止一个类被实例化的方法？

+ 如何禁止程序自动生成拷贝构造函数？

+ 成员函数中 memset(this, 0, sizeof(this)) 会发生什么？

+ 为什么友元函数必须在内部声明？

---

**独立特性（范式编程，异常机制、元编程、STL标准库）**

+ 迭代器失效的情况？

+ C++ 异常处理方法？（C++ 是如何处理多个异常的）

+ C/C++ 类型安全？

+ C++ 模板是什么，底层是如何实现的？

+ 模板函数和模板类的用法？

+ 智能指针的作用、原理、常用的智能指针及实现？

+ auto_ptr 作用？

+ 智能指针的循环引用？

+ 智能指针管理内存资源，RAII是什么？

+ 手写实现智能指针类？

+ 智能指针出现循环引用怎么解决？

+ C++ 11 有哪些新特性？

+ 模板类和模板函数的区别？

+ 为什么模板类一般都放在一个 .h 文件中？

+ 迭代器 ++it、it++ 哪个好，为什么？

+ 模板和实现写一个文件中可不可以？为什么？

+ C++ 中标准库是什么？

+ 写一个比较大小的模板？

+ STL 的 hashtable 实现

+ STL 的 traits 技法？

+ STL 的两级空间配置器？（一级配置器，二级配置器，一级分配器，二级分配器）

+ vector 和 list 的区别与应用，怎么找到某 vector 和 list 的倒数第二个元素?

+ STL 中 vector 删除其中的元素，迭代器如何变化？为什么是两倍扩容？释放空间？

+ STL 容器内部删除一个元素？

+ STL 迭代器如何实现？

+ map、set 如何实现的，红黑树是怎么能够同时使用这两种容器的？为什么使用红黑树？

+ 如何在共享内存中使用 STL 标准库？

+ map 插入有几种方式？

+ STL 的 unordered_map(hash_map) 和 map 的区别？hash_map 如何解决冲突和扩容？

+ vector 越界访问下标，map 越界访问下标？ vector 删除元素会不会释放空间？

+ map 中的 [] 和 find 有什么区别？

+ STL 中的 list 和 queue 区别？

+ STL 的 allocator deallocator

+ STL 的 hash_map 扩容发生了什么？

+ 常见的容器性质总结？

+ vector 的增加删除是怎么做到的，为什么是 1.5 或者是 2？

+ 说一下 STL 每种容器对于的迭代器？

+ STL 的 vector 实现

+ STL 的 slist 实现

+ STL 的 list 实现

+ STL 的 deque 实现

+ STL 的 stack 和 queue 实现

+ STL 的 heap 实现

+ STL 的 priority_queue 实现

+ STL 的 set 实现

+ STL 的 map 实现

+ set 和 map 的区别，multimap 和 multiset 的区别？

+ STL 的 unordered_map 和 map 的区别和应用场景？

+ hashtable 中解决冲突的方法？
----









