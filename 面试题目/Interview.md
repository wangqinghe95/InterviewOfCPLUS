# 20200924
# C++知识点
## C/C++语言
1. 谈谈你对C和C++的编程差异理解
	+ 他们最重要的是设计思想和应用场景的不同；
	+ 出于对内存和执行效率的考虑，C 的优点是精简和高效，多用于操作系统和内核驱动；而 C++ 设计之初的目的就是想把 C 繁杂的实现过程抽象成类，并且进行实例化管理，适合做大型软件。总结就是 C 更注重逻辑实现, C++ 更适合程序的整体设计。
	+ C++ 和 C 的基础语法是没有特别差异，但是 C++ 会有多很多特性，比如引用，new/delete，auto/decltype，重载虚函数，还有面向对象部分的类，继承，对象的内容。还有范式编程，异常机制，元编程，STL标准库这些特性。

---

2. static关键字在C语言和C++中各自有哪些不同用法？
	+ static 主要分为修饰全局变量，局部变量，函数，C++的成员函数和成员变量；
	+ 修饰全局变量改变的是该变量的可见范围，从原来所有文件可见状态变成只有当前文件可见；
	+ 修改局部变量和函数改变的是修饰对象的生存周期，从原来函数的生存周期变成整个程序的生存周期；
	+ 修饰成员函数和成员变量，修饰的函数和变量是被整个类的对象所共有。静态成员函数中不包含this指针。

	+ static 修饰的变量放在全局区，修饰的函数
	+ 修饰的成员函数不能和 const（放在函数后） 一起使用，是因为 const 修饰的函数需要一个隐藏的 const this* 指针

---

3. union是什么，有什么用？
	+ 共用体，也叫联合体。在一个联合体内可以定义多种不同的数据类型，这些数据共享同一段内存。union 所占的内存长度等于最长的成员的内存长度且是能被所有被包含的基础数据类型整除。目的是为了节省内存地址。

---

4. volatile关键字是做什么用的？
	+ 编译器不在对 volatile 修饰的对象做优化。直接从对象所在的内存地址中去读该值。

---

5. 函数调用过程在汇编层面如何进行？
	+ 函数的调用过程为压栈，跳转，执行代码，返回：
		1. 压栈：返回地址压栈，函数参数压栈；
		2. 跳转：跳转到函数所在代码处执行；
		3. 执行：执行函数代码；
		4. 返回：平衡堆栈，找出之前的返回地址，跳转回之前的调用点之后，完成函数调用。

---

6. 面向对象有哪些基本特性？
	1. 封装：把对象的服务和属性结合成一个独立的服务单元，并尽可能的隐藏其内部细节。
	2. 继承：特殊类拥有一般类的服务和属性。通过继承利用已有的数据结构去构造新的数据结构。
	3. 多态：同一操作作用于不同对象产生不同的效果，可以简单的概括为一个接口多个实现。

---

7. 多态是如何实现的？
	1. C++ 编译器为每个含有虚函数的类提供一个虚函数表，虚表用来记录虚函数地址，即虚表中的指针指向虚函数地址。当子类重写父类的虚函数时，子类继承的虚函数表地址相应位置会被修改为子类的虚函数地址。这样父类指针就可以调用子类重写的虚函数，从而实现多态。

---

8、编程实现一个单例模式
+ 单例要点：
	1. 全局只有一个实例，static特性，并且禁止用户自己声明并且定义实例（把构造函数设定为private）；
	2. 线程安全；
	3. 禁止赋值和拷贝；
	4. 用户通过接口获取实例；

+ 代码：InterviewCodeA.cpp

---

9. 影响C++对象大小的因素
	+ 所有非静态成员变量的大小
	+ 字节对齐和字节填充
	+ 虚函数指针
	+ 派生类继承的基类数据的数据成员

注：空类（无静态数据成员）对象大小为1，当作为基类时，大小为0.

Question：（64bit Operate System）
+	Q: 一个对象只有一个int型成员变量，sizeof的大小是多少？
-	A：4
+	Q：一个对象有一个int型和一个char型成员变量，sizeof的大小是多少？
-	Q：8（字节对齐）
+	Q：一个对象只有一个int型成员变量和一个虚函数，sizeof的大小是多少？
-	A：16（字节对齐，虚函数指针，8位）

---

12. 智能指针的原理？
	1. 原理：智能指针实际上是一个对普通指针封装的一个类。将动态分配的资源交给一个类对象去管理，当这个类的生命周期结束时自动调用析构函数释放资源。
		+ shared_ptr：使用引用计数器允许多个智能指针指向同一个对象。引用计数器为 0 时，自动释放释放资源达到防止资源泄漏的目的。
		+ unique_ptr：只允许一个智能指针指向一个对象。不支持普通的拷贝和赋值操作。可以转移一个 unique_ptr 指针的对象，move 移动拷贝构造函数。
		+ weak_ptr：弱指针，主要是解决 shared_ptr 产生的环形引用的问题。weak_ptr 只引用不计数，它指向的内存可能是无效的，使用前最后检查一些它是否为空。

---

13. vector容量满了会发生什么？
	+ 会重新申请一块大小为当前内存大小 1.5 倍的内存，然后再将当前的数据拷贝到新的内存中，再释放旧的内存空间。

	+ resize 和 reserve 的区别：
		+ vector 有容量（capacity）和长度（size）的区别。
		+ capacity 是预分配的空间，size 是当前数组已使用的长度大小。
		+ reserve 调整的是数组容量大小；resize 调整的是已使用的空间大小。

---

14. map和unordered_map各自如何实现？
	+ map 实现原理是红黑树，内部元素有序；增删查的时间复杂度都是 logn 级别的；缺点是空间占用率较大；
	+ unordered_map：使用hash表实现的；查找的时间复杂度是 O(1)；缺点是建立hash表比较耗费时间；

---

15. 右值引用是什么，move是为了解决什么问题？
	+ 是对临时变量的一种引用方法，在初始化完成之后，仍然可以改变临时对象的值；
	+ move 是将对象的所有权从一个对象转移到另一个对象，没有内存搬迁或者拷贝；主要是为了解决拷贝构造函数的一些额外消耗；

---

16. 构造函数能不能抛出异常？析构函数呢？
	1. 构造函数可以抛出异常，但是抛出异常后会导致析构函数无法被调用，但是对象申请到的内存资源会被系统释放；因为析构函数不能被调用所以有内存泄漏的风险；总结就是构造函数可以抛出异常，但是必须保证在构造函数抛出异常之前，把系统资源释放掉；
	2. 析构函数不能抛出异常。虽然C++并不禁止析构函数抛出异常，但是这样会导致程序过早结束或者出现不明确的行为。

---

17. C++中哪几种类型转换，区别是什么？
	1. reinterpret_cast:类型之间的转换
	2. const_cast:用于修改类型的 const 和 validate 属性；
	3. static_cast：派生类指针或引用转换为基类
	4. dynamic_cast: 基类指针或引用转换成派生类

（代码补充）
---

18. 从源代码到可执行程序，中间的过程是什么样的？
	1. 预编译：处理 # 号开头的预处理命令
	2. 编译：生成汇编文件
	3. 汇编：生成重定向文件
	4. 链接：将可重定向文件做静态链接和动态链接处理
	5. 可执行程序：生成可执行文件
	
---

# 0x02：数据结构与算法部分
1. 二叉树的四种遍历方式
	+ 前序遍历、中序遍历、后序遍历、层次遍历

---

2. 哈希表工作原理，如何解决哈希冲突？
	+ 工作原理：hash表是一个可以根据关键码值直接访问的数据结构，其原理是通过将关键码值映射到表中的特定位置。其中映射函数叫做散列函数，存放记录数组叫做散列表。采用散列技术将数据存储在一块连续的的存储空间中。
	+ 解决冲突的方法：
		1. 线性探测法：当发生冲突时，继续向后遍历，直到找到一个空位来存放当前数据；
		2. 开链法：每个 hash 表的表格维护一个链表，将每个映射过来的数据直接插入到链表尾部；
		3. 再散列：发生冲突后使用另一种映射函数重新计算一个新的地址，直到不再冲突为止；
		4. 二次探测：发生冲突后，按照步长的平方距离继续寻找空位；

---

3. 编程实现一个二分查找
	+ 代码：InterviewCodeA.cpp
---

4. 常用的排序算法，各自的平均时间复杂度是什么？

	+ 冒泡排序：O(N^2)
	+ 插入排序：O(N^2)
	+ 选择排序：O(N^2)
	+ 希尔排序：O(NlogN)
	+ 快速排序：O(NlogN)
	+ 堆排序：	O(NlogN)
	+ 归并排序：O(NlogN)

	+ 代码：InterviewCodeA.cpp
---

5. 1-2走台阶问题，递归和动态规划两种解题方法
	+ 代码：InterviewCodeA.cpp
---

6. 一个一维数组，先单调递增，后单调递减，如何找到这个拐点？
+ 思路1：二分法-拐点的定义是局部最大，意思是要大于左侧和右侧。通过二分法来找
```
int getBreakPoint(vector<int> &arr) {
    int left = 0;
    int right = arr.size() - 1;
    while (left < right) {
        int mid = (left + right) / 2;
        if (mid > 0 && arr[mid] > arr[mid-1]) {
            left = mid;
        }
        if (mid < arr.size() - 1 && arr[mid] > arr[mid+1]) {
            right = mid;
        }
    }
    return left;
}
```
+ 思路2：从左侧到右侧遍历，拐点值要大于左侧且右侧的值。
+ 如果是严格的先增后减，就不会有最大值在第一位和最后一位的情况了
```
	for (int i = 1; i < arr.size()-1; ++i) {
		if (arr[i] > arr[i-1] && arr[i] > arr[i+1]) {
			return arr[i];
		}
	}
```
---

7. 如何设计一个算法，快速判断一个IP地址有没有在系统中出现过？
+ 使用位图存储，0号位代表 0.0.0.0; 1 代表 0.0.0.1, 128(2^8)代表 0.0.0.127,256 代表 0.0.0.255, 2^32 可以代表 255.255.255.255
+ 一共 2^32 次方的 bitmap，需要约 512MB 大小的内存空间，查询O(1),插入O(n)

---
8. 设计一个线程安全的队列。
+ 对队列和线程的互斥量和条件变量进行封装，对于队列的插入、删除、查询的操作都进行加锁设置，保证多线程操作该队列数据时是串行操作；

---

0x03：操作系统
1. 进程和线程的区别？
	+ 最本质的区别：进程是操作系统分配资源的最小单位，而线程是处理器任务调度和执行的最小单位；
	+ 系统开销的区别：
	+ 包含关系：
	+ 内存分配：
	+ 执行条件：

---

2. 进程地址空间里面有什么东西？
	+ 栈、堆、全局常量区、代码区；

---

3. 线程的栈里面有哪些东西？
	+ 程序计数器、栈指针；
---
4. fork的原理是什么？

---
5、进程间通信有哪些方式？
6、共享内存的原理是什么？
7、原子操作的原理是什么？
8、I/O多路复用有哪些模型？
9、epoll高性能的原因有哪些？
10、谈一谈signal机制
11、什么是系统调用，执行系统调用的过程是什么？
12、写时拷贝是什么，底层实现原理？

0x04：计算机网络
1、四层模型是哪四层，各自负责什么功能？
2、ping命令是什么原理？
3、traceroute是什么原理？
4、什么是ARP欺骗？
5、集线器、交换机、路由器的区别？
6、什么是MTU？为什么是这个大小？
7、TCP三次握手和四次挥手机制
8、TCP的第三次握手可以携带数据吗？
9、TCP可靠性由哪些机制保证？
10、超时重传如何进行？
11、DNS解析过程如何进行？
12、HTTP中有哪些Method，POST和PUT什么区别？
13、HTTP1.0和1.1有什么区别？s
14、HTTPS安全性的原理
15、什么是反向代理？nginx负载均衡有哪些策略？
16、从输入网址到网页内容展示出来，发生了哪些事？

0x05：数据库
1、什么是数据库索引？
2、MySQL数据库索引有哪些实现方式？
3、B+树和哈希索引各自的应用场景？
4、什么是回表？
5、什么是事务？事务的基本特性？
6、分库分表有哪些方案？有什么区别？
7、什么是缓存击穿、缓存雪崩、缓存穿透？
8、Redis单线程为什么很快？
9、Redis怎么实现消息队列？
10、Redis有哪些持久化方式？各自实现原理？
11、ElasticSearch基本原理？